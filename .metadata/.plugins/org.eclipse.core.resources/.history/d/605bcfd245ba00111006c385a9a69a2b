package development;

import java.io.*;
import java.util.*;

/**
 * Parsing class to convert a PCOM .KMP file to a HOD .KMP file which have
 * slightly different syntax as well as different physical key values.
 * @author aguiber
 */
public class Parse {

	private static FileWriter fstream;
	private static BufferedWriter out;

	/**
	 * Converts a given .KMP file in a PCOM format and converts it to the HOD
	 * format .KMP file.
	 * @param args
	 *            args[0] a .KMP file from PCOM, which is to be converted to HOD
	 *            format args[1] a destination file for the output to be written
	 *            to (NOTE: EXISTING TEXT WILL BE ERASED FROM THIS FILE)
	 */
	public static void main(String args[]) {

		// Obtain the target file location
		try {
			//fstream = new FileWriter("C:/Users/IBM_ADMIN/Desktop/output.kmp"); // absolute location used only for faster testing
			fstream = new FileWriter(args[1]);
			out = new BufferedWriter(fstream);
		} 
		catch (Exception e) {// Catch exception if any
			System.err.println("Error: " + e.getMessage());
		}

		// Obtain a path location where the .KMP file for the PCOM is located
		String file;
		try {
			//file = "C:/Users/IBM_ADMIN/AppData/Roaming/IBM/Personal Communications/test1.KMP"; // absolute location used only for faster testing
			file = args[0];
			if (file.contains(".KMP")) {
			} else {
				System.out.println("File was not a .KMP file, continuing anyways...");
			}
		} catch (ArrayIndexOutOfBoundsException ex) {
			System.out.println("File not found, a test file...");
			file = "C:/Users/IBM_ADMIN/AppData/Roaming/IBM/Personal Communications/test1.KMP";
		}

		/**********************************/
		/**        Function Calls        **/
		/**********************************/
		// Runs parse function, will store all information from target file into an array
		String PCOMKeys[][] = parse(file);
		
		// Convert PCOMKeys to HODKeys
		String HODKeys[][] = convert(PCOMKeys);
		
		// Carry over the defaults PComm key maps and write to output file
		xferDefaults(HODKeys);
		
		// Write output to a file
		writeOutput(HODKeys);
		
		System.out.println("KMP conversion complete.");
	}

	/**
	 * Converts both physical key number and function name from PCOM format to 
	 * HOD format.  Handles key modifier conversion separately, sends physical 
	 * key number conversion and function name conversion to help methods.
	 * @param PCOMKeys
	 * 			Represents information parsed out of the user defined key maps
	 * 			in PCOM.
	 * @return
	 * 			2D array which contains the HOD equivalents for the PCOM input array
	 */
	public static String[][] convert(String PCOMKeys[][]) {

		int numlines = PCOMKeys.length;
		String HODKeys[][] = new String[numlines][2];
		for (int line = 0; line < numlines; line++) {
			/**********************************/
			/**        Convert part 1        **/
			/**********************************/
			// Example: PCOM: G-KEY43 -> HOD:I10
			/******** Convert Modifier ********/
			// Example: Ctrl+Shift... PCOM:CS -> HOD:D
			// No modifier
			if (PCOMKeys[line][0].charAt(0) == 'K') {
				HODKeys[line][0] = "B";
			}
			// Ctrl modifier
			else if (PCOMKeys[line][0].charAt(0) == 'C') {
				if (PCOMKeys[line][0].charAt(1) == 'S') {
					HODKeys[line][0] = "D";
				} else
					HODKeys[line][0] = "C";
			}
			// (ctrl + alt) or (alt + ctrl)
			else if (PCOMKeys[line][0].charAt(0) == 'G') {
				HODKeys[line][0] = "I";
			}
			// Shift modifier
			else if (PCOMKeys[line][0].charAt(0) == 'S') {
				HODKeys[line][0] = "S";
			}
			// Alt modifier
			else if (PCOMKeys[line][0].charAt(0) == 'A') {
				HODKeys[line][0] = "A";
			} else {
				HODKeys[line][0] = "*keyUnhErr";
			}
			/******** Convert Physical Key No. ********/
			int indexOfKeyNum = PCOMKeys[line][0].indexOf('Y') + 1;
			int keyNum = Integer.parseInt(PCOMKeys[line][0]
					.substring(indexOfKeyNum));
			int HODKeyNum = toHODKeyNum(keyNum);
			HODKeys[line][0] += String.valueOf(HODKeyNum);

			/**********************************/
			/**        Convert part 2        **/
			/**********************************/
			/******** Convert Function Name ********/
			// Example: PCOM:[Field exit] -> HOD:[fldext]
			HODKeys[line][1] = toHODFunction(PCOMKeys[line][1]);

			/******** Handle errors for input ********/
			if (HODKeys[line][0].contains("*keyUnhErr")
					|| HODKeys[line][1].contains("*macUnhErr")
					|| HODKeys[line][1].contains("*funcUnhErr")) {
				System.out.println("Key: " + PCOMKeys[line][0] + "\tFunction: "
						+ PCOMKeys[line][1]
						+ "\twas **NOT** converted to \tKey: "
						+ HODKeys[line][0] + "  Function: " + HODKeys[line][1]
						+ ".");
				HODKeys[line][0] = "*genErr";
				HODKeys[line][1] = "*genErr";
			}
		}

		return HODKeys;
	}

	/**
	 * Converts from a PCOM function name to a HOD function name
	 * @param PCOMfunction
	 * 				Given PCOM function name which is to be converted
	 * @return
	 * 				Equivalent HOD function name, if no equivalent function
	 * 				exists, returns a string representing an error.  This is 
	 * 				handled at a later point.
	 */
	private static String toHODFunction(String PCOMfunction) {

		String HODFunction = "***NOT_CONVERTED***";
		// Line is a macro
		if ((PCOMfunction.charAt(0) == 'm' || PCOMfunction.charAt(0) == 'M')
				&& PCOMfunction.charAt(1) == 'a'
				&& PCOMfunction.charAt(2) == 'c'
				&& PCOMfunction.charAt(3) == 'r'
				&& PCOMfunction.charAt(4) == 'o') {
			// TODO handle macro's
			HODFunction = "*macUnhErr";
		} 
		else if (PCOMfunction.compareToIgnoreCase("[alt cursor]") == 0)
			HODFunction = "[altcsr]";
		else if (PCOMfunction.compareToIgnoreCase("[alt view]") == 0)
			HODFunction = "[altview]";
		else if (PCOMfunction.compareToIgnoreCase("[sys attn]") == 0)
			HODFunction = "[attn]";
		else if (PCOMfunction.compareToIgnoreCase("[backspace]") == 0)
			HODFunction = "[backspace]";
		else if (PCOMfunction.compareToIgnoreCase("[backtab]") == 0)
			HODFunction = "[backtab]";
		else if (PCOMfunction.compareToIgnoreCase("[backtab word]") == 0)
			HODFunction = "[backtab word]";
		else if (PCOMfunction.compareToIgnoreCase("[Base]") == 0)
			HODFunction = "[base]";
		else if (PCOMfunction.compareToIgnoreCase("[clear]") == 0)
			HODFunction = "[clear]";
		else if (PCOMfunction.compareToIgnoreCase("[Close]") == 0)
			HODFunction = "[close]";
		else if (PCOMfunction.compareToIgnoreCase("[CSD On-Off]") == 0)
			HODFunction = "[csd]";
		else if (PCOMfunction.compareToIgnoreCase("[down]") == 0)
			HODFunction = "[down]";
		else if (PCOMfunction.compareToIgnoreCase("[left]") == 0)
			HODFunction = "[left]";
		else if (PCOMfunction.compareToIgnoreCase("[right]") == 0)
			HODFunction = "[right]";
		else if (PCOMfunction.compareToIgnoreCase("[cursor select]") == 0)
			HODFunction = "[cursel]";
		else if (PCOMfunction.compareToIgnoreCase("[up]") == 0)
			HODFunction = "[up]";
		else if (PCOMfunction.compareToIgnoreCase("[delete char]") == 0)
			HODFunction = "[delete]";
		else if (PCOMfunction.compareToIgnoreCase("[DisplayPoppad]") == 0)
			HODFunction = "[DisplayPoppad]";
		else if (PCOMfunction.compareToIgnoreCase("[DisplayPoppad1]") == 0)
			HODFunction = "[DisplayPoppad1]";
		else if (PCOMfunction.compareToIgnoreCase("[DisplayPoppad2]") == 0)
			HODFunction = "[DisplayPoppad2]";
		else if (PCOMfunction.compareToIgnoreCase("[DisplayPoppad3]") == 0)
			HODFunction = "[DisplayPoppad3]";
		else if (PCOMfunction.compareToIgnoreCase("[DisplayPoppad4]") == 0)
			HODFunction = "[DisplayPoppad4]";
		else if (PCOMfunction.compareToIgnoreCase("[dup]") == 0)
			HODFunction = "[dup]";
		else if (PCOMfunction.compareToIgnoreCase("[edit-copy]") == 0)
			HODFunction = "[copy]";
		else if (PCOMfunction.compareToIgnoreCase("[edit-copyappend]") == 0)
			HODFunction = "[copyappend]";
		else if (PCOMfunction.compareToIgnoreCase("[edit-cut]") == 0)
			HODFunction = "[cut]";
		else if (PCOMfunction.compareToIgnoreCase("[edit-paste]") == 0)
			HODFunction = "[paste]";
		else if (PCOMfunction.compareToIgnoreCase("[edit-paste-next]") == 0)
			HODFunction = "[pastenext]";
		else if (PCOMfunction.compareToIgnoreCase("[edit-undo]") == 0)
			HODFunction = "[undo]";
		else if (PCOMfunction.compareToIgnoreCase("[end of line]") == 0)
			HODFunction = "[eof]";
		else if (PCOMfunction.compareToIgnoreCase("[end push]") == 0)
			HODFunction = "[endpush]";
		else if (PCOMfunction.compareToIgnoreCase("[latinlayer]") == 0)
			HODFunction = "[latinlayer]";
		else if (PCOMfunction.compareToIgnoreCase("[enter]") == 0)
			HODFunction = "[enter]";
		else if (PCOMfunction.compareToIgnoreCase("[erase eof]") == 0)
			HODFunction = "[eraseeof]";
		else if (PCOMfunction.compareToIgnoreCase("[erase field]") == 0)
			HODFunction = "[erasefld]";
		else if (PCOMfunction.compareToIgnoreCase("[erase input]") == 0)
			HODFunction = "[erinp]";
		else if (PCOMfunction.compareToIgnoreCase("[field-]") == 0)
			HODFunction = "[field-]";
		else if (PCOMfunction.compareToIgnoreCase("[Field Base]") == 0)
			HODFunction = "[fieldbase]";
		else if (PCOMfunction.compareToIgnoreCase("[field exit]") == 0)
			HODFunction = "[fldext]";
		else if (PCOMfunction.compareToIgnoreCase("[field mark]") == 0)
			HODFunction = "[fieldmark]";
		else if (PCOMfunction.compareToIgnoreCase("[Sreverse]") == 0)
			HODFunction = "[fldrev]";
		else if (PCOMfunction.compareToIgnoreCase("[Field Shape]") == 0)
			HODFunction = "[fieldshape]";
		else if (PCOMfunction.compareToIgnoreCase("[field+]") == 0)
			HODFunction = "[field+]";
		else if (PCOMfunction.compareToIgnoreCase("[Final On]") == 0)
			HODFunction = "[final]";
		else if (PCOMfunction.compareToIgnoreCase("[+cr]") == 0)
			HODFunction = "[+cr]";
		else if (PCOMfunction.compareToIgnoreCase("[help]") == 0)
			HODFunction = "[help]";
		else if (PCOMfunction.compareToIgnoreCase("[home]") == 0)
			HODFunction = "[home]";
		else if (PCOMfunction.compareToIgnoreCase("[host print]") == 0)
			HODFunction = "[printhost]";
		else if (PCOMfunction.compareToIgnoreCase("[Initial On]") == 0)
			HODFunction = "[initial]";
		else if (PCOMfunction.compareToIgnoreCase("[insert]") == 0)
			HODFunction = "[insert]";
		else if (PCOMfunction.compareToIgnoreCase("[Isolated On]") == 0)
			HODFunction = "[isolated]";
		else if (PCOMfunction.compareToIgnoreCase("[jump next]") == 0)
			HODFunction = "[jump]";
		else if (PCOMfunction.compareToIgnoreCase("[mark down]") == 0)
			HODFunction = "[markdown]";
		else if (PCOMfunction.compareToIgnoreCase("[mark left]") == 0)
			HODFunction = "[markleft]";
		else if (PCOMfunction.compareToIgnoreCase("[mark right]") == 0)
			HODFunction = "[markright]";
		else if (PCOMfunction.compareToIgnoreCase("[mark up]") == 0)
			HODFunction = "[markup]";
		else if (PCOMfunction.compareToIgnoreCase("[Middle On]") == 0)
			HODFunction = "[middle]";
		else if (PCOMfunction.compareToIgnoreCase("[move down]") == 0)
			HODFunction = "[movedown]";
		else if (PCOMfunction.compareToIgnoreCase("[move left]") == 0)
			HODFunction = "[moveleft]";
		else if (PCOMfunction.compareToIgnoreCase("[move right]") == 0)
			HODFunction = "[moveright]";
		else if (PCOMfunction.compareToIgnoreCase("[move up]") == 0)
			HODFunction = "[moveup]";
		else if (PCOMfunction.compareToIgnoreCase("[bidilayer]") == 0)
			HODFunction = "[bidilayer]";
		else if (PCOMfunction.compareToIgnoreCase("[newline]") == 0)
			HODFunction = "[newline]";
		else if (PCOMfunction.compareToIgnoreCase("[next word]") == 0)
			HODFunction = "[nextword]";
		else if (PCOMfunction.compareToIgnoreCase("[page down]") == 0)
			HODFunction = "[pagedn]";
		else if (PCOMfunction.compareToIgnoreCase("[page up]") == 0)
			HODFunction = "[pageup]";
		else if (PCOMfunction.compareToIgnoreCase("[local copy]") == 0)
			HODFunction = "[print]";
		else if (PCOMfunction.compareToIgnoreCase("[pa1]") == 0)
			HODFunction = "[pa1]";
		else if (PCOMfunction.compareToIgnoreCase("[pa2]") == 0)
			HODFunction = "[pa2]";
		else if (PCOMfunction.compareToIgnoreCase("[pa3]") == 0)
			HODFunction = "[pa3]";
		else if (PCOMfunction.compareToIgnoreCase("[pf1]") == 0)
			HODFunction = "[pf1]";
		else if (PCOMfunction.compareToIgnoreCase("[pf2]") == 0)
			HODFunction = "[pf2]";
		else if (PCOMfunction.compareToIgnoreCase("[pf3]") == 0)
			HODFunction = "[pf3]";
		else if (PCOMfunction.compareToIgnoreCase("[pf4]") == 0)
			HODFunction = "[pf4]";
		else if (PCOMfunction.compareToIgnoreCase("[pf5]") == 0)
			HODFunction = "[pf5]";
		else if (PCOMfunction.compareToIgnoreCase("[pf6]") == 0)
			HODFunction = "[pf6]";
		else if (PCOMfunction.compareToIgnoreCase("[pf7]") == 0)
			HODFunction = "[pf7]";
		else if (PCOMfunction.compareToIgnoreCase("[pf8]") == 0)
			HODFunction = "[pf8]";
		else if (PCOMfunction.compareToIgnoreCase("[pf9]") == 0)
			HODFunction = "[pf9]";
		else if (PCOMfunction.compareToIgnoreCase("[pf10]") == 0)
			HODFunction = "[pf10]";
		else if (PCOMfunction.compareToIgnoreCase("[pf11]") == 0)
			HODFunction = "[pf11]";
		else if (PCOMfunction.compareToIgnoreCase("[pf12]") == 0)
			HODFunction = "[pf12]";
		else if (PCOMfunction.compareToIgnoreCase("[pf13]") == 0)
			HODFunction = "[pf13]";
		else if (PCOMfunction.compareToIgnoreCase("[pf14]") == 0)
			HODFunction = "[pf14]";
		else if (PCOMfunction.compareToIgnoreCase("[pf15]") == 0)
			HODFunction = "[pf15]";
		else if (PCOMfunction.compareToIgnoreCase("[pf16]") == 0)
			HODFunction = "[pf16]";
		else if (PCOMfunction.compareToIgnoreCase("[pf17]") == 0)
			HODFunction = "[pf17]";
		else if (PCOMfunction.compareToIgnoreCase("[pf18]") == 0)
			HODFunction = "[pf18]";
		else if (PCOMfunction.compareToIgnoreCase("[pf19]") == 0)
			HODFunction = "[pf19]";
		else if (PCOMfunction.compareToIgnoreCase("[pf20]") == 0)
			HODFunction = "[pf20]";
		else if (PCOMfunction.compareToIgnoreCase("[pf21]") == 0)
			HODFunction = "[pf21]";
		else if (PCOMfunction.compareToIgnoreCase("[pf22]") == 0)
			HODFunction = "[pf22]";
		else if (PCOMfunction.compareToIgnoreCase("[pf23]") == 0)
			HODFunction = "[pf23]";
		else if (PCOMfunction.compareToIgnoreCase("[pf24]") == 0)
			HODFunction = "[pf24]";
		else if (PCOMfunction.compareToIgnoreCase("[push]") == 0)
			HODFunction = "[push]";
		else if (PCOMfunction.compareToIgnoreCase("[reset]") == 0)
			HODFunction = "[reset]";
		else if (PCOMfunction.compareToIgnoreCase("[reset/ctrl]") == 0)
			HODFunction = "[enterreset]";
		else if (PCOMfunction.compareToIgnoreCase("[rule]") == 0)
			HODFunction = "[rule]";
		else if (PCOMfunction.compareToIgnoreCase("[screen reverse]") == 0)
			HODFunction = "[screenrev]";
		else if (PCOMfunction.compareToIgnoreCase("[PoppadFocus]") == 0)
			HODFunction = "[PoppadFocus]";
		else if (PCOMfunction.compareToIgnoreCase("[so si]") == 0)
			HODFunction = "[dspsosi]";
		else if (PCOMfunction.compareToIgnoreCase("[sys req]") == 0)
			HODFunction = "[sysreq]";
		else if (PCOMfunction.compareToIgnoreCase("[tab field]") == 0)
			HODFunction = "[tab]";
		else if (PCOMfunction.compareToIgnoreCase("[tab word]") == 0)
			HODFunction = "[tabword]";
		else if (PCOMfunction.compareToIgnoreCase("[test]") == 0)
			HODFunction = "[test]";
		else if (PCOMfunction.compareToIgnoreCase("[unmark]") == 0)
			HODFunction = "[unmark]";
		else if (PCOMfunction.compareToIgnoreCase("[vt cursor direction]") == 0)
			HODFunction = "[cursorrev]";
		else if (PCOMfunction.compareToIgnoreCase("[vt numpad minus]") == 0)
			HODFunction = "[keypad-]";
		else if (PCOMfunction.compareToIgnoreCase("[vt numpad comma]") == 0)
			HODFunction = "[keypad,]";
		else if (PCOMfunction.compareToIgnoreCase("[vt numpad period]") == 0)
			HODFunction = "[keypad.]";
		else if (PCOMfunction.compareToIgnoreCase("[vt numpad 0]") == 0)
			HODFunction = "[keypad 0]";
		else if (PCOMfunction.compareToIgnoreCase("[vt numpad 1]") == 0)
			HODFunction = "[keypad 1]";
		else if (PCOMfunction.compareToIgnoreCase("[vt numpad 2]") == 0)
			HODFunction = "[keypad 2]";
		else if (PCOMfunction.compareToIgnoreCase("[vt numpad 3]") == 0)
			HODFunction = "[keypad 3]";
		else if (PCOMfunction.compareToIgnoreCase("[vt numpad 4]") == 0)
			HODFunction = "[keypad 4]";
		else if (PCOMfunction.compareToIgnoreCase("[vt numpad 5]") == 0)
			HODFunction = "[keypad 5]";
		else if (PCOMfunction.compareToIgnoreCase("[vt numpad 6]") == 0)
			HODFunction = "[keypad 6]";
		else if (PCOMfunction.compareToIgnoreCase("[vt numpad 7]") == 0)
			HODFunction = "[keypad 7]";
		else if (PCOMfunction.compareToIgnoreCase("[vt numpad 8]") == 0)
			HODFunction = "[keypad 8]";
		else if (PCOMfunction.compareToIgnoreCase("[vt numpad 9]") == 0)
			HODFunction = "[keypad 9]";
		else if (PCOMfunction.compareToIgnoreCase("[vt numpad enter]") == 0)
			HODFunction = "[keypadenter]";
		else if (PCOMfunction.compareToIgnoreCase("[Word Wrap]") == 0)
			HODFunction = "[wordwrap]";
		else
			HODFunction = "*funcUnhErr";
		return HODFunction;
	}

	/**
	 * Converts a given PCOM key number to the equivalent key as defined by HOD.
	 * @param keyNum
	 * 				A physical key number of a PCOM Key
	 * @return
	 * 				The equivalent physical key number for HOD
	 */
	private static int toHODKeyNum(int keyNum) {

		int HODKeyNum = -1;
		switch (keyNum) {
		case 1:
			HODKeyNum = 192;
			break;
		case 2:
			HODKeyNum = 49;
			break;
		case 3:
			HODKeyNum = 50;
			break;
		case 4:
			HODKeyNum = 51;
			break;
		case 5:
			HODKeyNum = 52;
			break;
		case 6:
			HODKeyNum = 53;
			break;
		case 7:
			HODKeyNum = 54;
			break;
		case 8:
			HODKeyNum = 55;
			break;
		case 9:
			HODKeyNum = 56;
			break;
		case 10:
			HODKeyNum = 57;
			break;
		case 11:
			HODKeyNum = 48;
			break;
		case 12:
			HODKeyNum = 45;
			break;
		case 13:
			HODKeyNum = 61;
			break;
		// case 14: HODKeyNum = 10; break;
		case 15:
			HODKeyNum = 8;
			break;
		case 16:
			HODKeyNum = 9;
			break;
		case 17:
			HODKeyNum = 81;
			break;
		case 18:
			HODKeyNum = 87;
			break;
		case 19:
			HODKeyNum = 69;
			break;
		case 20:
			HODKeyNum = 82;
			break;
		case 21:
			HODKeyNum = 84;
			break;
		case 22:
			HODKeyNum = 89;
			break;
		case 23:
			HODKeyNum = 85;
			break;
		case 24:
			HODKeyNum = 73;
			break;
		case 25:
			HODKeyNum = 79;
			break;
		case 26:
			HODKeyNum = 80;
			break;
		case 27:
			HODKeyNum = 91;
			break;
		case 28:
			HODKeyNum = 93;
			break;
		case 29:
			HODKeyNum = 92;
			break;
		case 30:
			HODKeyNum = 20;
			break;
		case 31:
			HODKeyNum = 65;
			break;
		case 32:
			HODKeyNum = 83;
			break;
		case 33:
			HODKeyNum = 68;
			break;
		case 34:
			HODKeyNum = 70;
			break;
		case 35:
			HODKeyNum = 71;
			break;
		case 36:
			HODKeyNum = 72;
			break;
		case 37:
			HODKeyNum = 74;
			break;
		case 38:
			HODKeyNum = 75;
			break;
		case 39:
			HODKeyNum = 76;
			break;
		case 40:
			HODKeyNum = 59;
			break;
		case 41:
			HODKeyNum = 222;
			break;
		// case 42: HODKeyNum = -2; break;
		case 43:
			HODKeyNum = 10;
			break;
		// case 44: HODKeyNum = 10; break;
		// case 45: HODKeyNum = 10; break;
		case 46:
			HODKeyNum = 90;
			break;
		case 47:
			HODKeyNum = 88;
			break;
		case 48:
			HODKeyNum = 67;
			break;
		case 49:
			HODKeyNum = 85;
			break;
		case 50:
			HODKeyNum = 66;
			break;
		case 51:
			HODKeyNum = 78;
			break;
		case 52:
			HODKeyNum = 77;
			break;
		case 53:
			HODKeyNum = 44;
			break;
		case 54:
			HODKeyNum = 46;
			break;
		case 55:
			HODKeyNum = 47;
			break;
		// case 56: HODKeyNum = 10; break;
		// case 57: HODKeyNum = 10; break;
		case 58:
			HODKeyNum = 17;
			break;
		// case 59: HODKeyNum = -2; break;
		// case 60: HODKeyNum = 10; break;
		case 61:
			HODKeyNum = 32;
			break;
		// case 62: HODKeyNum = 10; break;
		// case 63: HODKeyNum = 10; break;
		case 64:
			HODKeyNum = 17;
			break;
		// case 65: HODKeyNum = 10; break;
		// case 66: HODKeyNum = 10; break;
		// case 67: HODKeyNum = 10; break;
		// case 68: HODKeyNum = 10; break;
		// case 69: HODKeyNum = 10; break;
		// case 70: HODKeyNum = 10; break;
		// case 71: HODKeyNum = 10; break;
		// case 72: HODKeyNum = 10; break;
		// case 73: HODKeyNum = 10; break;
		// case 74: HODKeyNum = 10; break;
		case 75:
			HODKeyNum = 155;
			break;
		case 76:
			HODKeyNum = 127;
			break;
		// case 77: HODKeyNum = 10; break;
		// case 78: HODKeyNum = 10; break;
		case 79:
			HODKeyNum = 37;
			break;
		case 80:
			HODKeyNum = 36;
			break;
		case 81:
			HODKeyNum = 35;
			break;
		// case 82: HODKeyNum = 10; break;
		case 83:
			HODKeyNum = 38;
			break;
		case 84:
			HODKeyNum = 40;
			break;
		case 85:
			HODKeyNum = 33;
			break;
		case 86:
			HODKeyNum = 34;
			break;
		// case 87: HODKeyNum = 10; break;
		// case 88: HODKeyNum = 10; break;
		case 89:
			HODKeyNum = 39;
			break;
		case 90:
			HODKeyNum = 144;
			break;
		case 91:
			HODKeyNum = 103;
			break;
		case 92:
			HODKeyNum = 100;
			break;
		case 93:
			HODKeyNum = 97;
			break;
		// case 94: HODKeyNum = 10; break;
		case 95:
			HODKeyNum = 111;
			break;
		case 96:
			HODKeyNum = 104;
			break;
		case 97:
			HODKeyNum = 101;
			break;
		case 98:
			HODKeyNum = 98;
			break;
		case 99:
			HODKeyNum = 96;
			break;
		case 100:
			HODKeyNum = 106;
			break;
		case 101:
			HODKeyNum = 105;
			break;
		case 102:
			HODKeyNum = 102;
			break;
		case 103:
			HODKeyNum = 99;
			break;
		case 104:
			HODKeyNum = 110;
			break;
		case 105:
			HODKeyNum = 109;
			break;
		case 106:
			HODKeyNum = 107;
			break;
		// case 107: HODKeyNum = 10; break;
		case 108:
			HODKeyNum = 10;
			break;
		// case 109: HODKeyNum = 10; break;
		case 110:
			HODKeyNum = 27;
			break;
		// case 111: HODKeyNum = 10; break;
		case 112:
			HODKeyNum = 112;
			break;
		case 113:
			HODKeyNum = 113;
			break;
		case 114:
			HODKeyNum = 114;
			break;
		case 115:
			HODKeyNum = 115;
			break;
		case 116:
			HODKeyNum = 116;
			break;
		case 117:
			HODKeyNum = 117;
			break;
		case 118:
			HODKeyNum = 118;
			break;
		case 119:
			HODKeyNum = 119;
			break;
		case 120:
			HODKeyNum = 120;
			break;
		case 121:
			HODKeyNum = 121;
			break;
		case 122:
			HODKeyNum = 122;
			break;
		case 123:
			HODKeyNum = 123;
			break;
		case 124:
			HODKeyNum = 154;
			break;
		case 125:
			HODKeyNum = 145;
			break;
		case 126:
			HODKeyNum = 19;
			break;
		default:
			HODKeyNum = -2;
		}
		return HODKeyNum;
	}

	/**
	 * Takes a string argument representing the file location and parses through
	 * it to produce an array containing information of the user defined keymaps
	 * @param strfile
	 *            String file: a string representation of the file location
	 *            which is to be parsed
	 * @return Returns a 2D array containing information about the user defined
	 *         keymaps
	 */
	public static String[][] parse(String strfile) {

		// Initialize a file and scanner
		// to use for the parse function
		File ffile = null;
		Scanner scanner = null;

		// Creates a file and scanner from the given arg
		try {
			ffile = new File(strfile);
			scanner = new Scanner(ffile);
		} catch (FileNotFoundException ex) {
			System.out.println("File not found");
		}

		// Find the size of array needed
		int numlines = 0;
		Scanner linecounter = null;
		try {
			linecounter = new Scanner(ffile);
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
		while (linecounter.hasNextLine()) {
			String currentline = linecounter.nextLine();
			if (currentline.contains("=") && currentline.contains("KEY")) {
				numlines++;
			}

		}
		String PCOMKeys[][] = new String[numlines][2];

		// Fill the array with information about user defined keymaps
		int increment = 0;
		while (scanner.hasNextLine()) {

			String currentline = scanner.nextLine();
			if (currentline.contains("=") && currentline.contains("KEY")) {

				// System.out.println(currentline);
				String parts[] = currentline.split("=");
				PCOMKeys[increment][0] = parts[0].trim();
				PCOMKeys[increment][1] = parts[1].replace("\"", "").trim();
				// System.out.println("First half is: " +
				// PCOMKeys[increment][0]);
				// System.out.println("Second half is: " +
				// PCOMKeys[increment][1]);
				increment++;
			}
		}

		return PCOMKeys;
	}

	/**
	 * Writes the information contained in a given array to a file.
	 * @param PCOMKeys
	 *            The array containing information about user defined keymaps
	 */
	public static void writeOutput(String Keys[][]) {

		try {
			// Step through array and write to the destination file
			for (int i = 0; i < Keys.length; i++) {
				if (Keys[i][1].compareToIgnoreCase("*genErr") != 0) {
					out.write(Keys[i][0]);
					out.write("=");
					out.write(Keys[i][1]);
					out.write('\n');
				}
			}
			// Close the output stream
			out.close();
		} catch (Exception e) {// Catch exception if any
			System.err.println("Error: " + e.getMessage());
		}
	}

	/**
	 * Parses through the pcomDefaults.kmp file and writes each line of
	 * pcomDefaults.kmp to the output file, as long as the user defined key maps
	 * do not interfere with default key maps. One function CAN be mapped to two
	 * different keys. But one key can NOT be mapped to two functions -- this
	 * function checks for this scenario.
	 * @param HODKeys
	 *            an array which contains user defined key map information.
	 */
	public static void xferDefaults(String[][] HODKeys) {

		try {
			File defaults = new File("./pcomDefaults.kmp");
			Scanner defaultsScanner = new Scanner(defaults);

			Boolean writeLine = true;
			while (defaultsScanner.hasNextLine()) {
				String curLine = defaultsScanner.nextLine();
				for (int i = 0; i < HODKeys.length; i++) {
					if (curLine.contains(HODKeys[i][0] + "=")) {
						writeLine = false;
					}
				}
				if (writeLine) {
					out.write(curLine);
					if (defaultsScanner.hasNextLine()) {
						out.write("\n");
					}
				} else {
					writeLine = true;
				}
			}
		} catch (Exception e) {// Catch exception if any
			System.err.println("Error: " + e.getMessage());
		}
	}
}
